#############################################################
#测试 xori, sltiu, lbu, blez 指令，执行正常应为27条指令
#############################################################
.text
addi  $v0,$0,34
#xori测试
#先将a0寄存器赋初值0xffff，用数码管显示
#然后用常量0xedcb进行异或操作，就将低4位置为0x1234，再用数码管显示
addi  $a0,$0,0xfff	#$a0=0xfff
syscall			#显示$a0的值，fff
xori  $a0,$a0,0xedc	#a0=0x123
syscall			#显示$a0的值，123
#xori测试结束

#sltiu测试
#设置寄存器s0初值为16，判断它是否小于15，结果不小于，所以a0寄存器被置为0，用数码管显示
#将寄存器s0赋值为14，判断它是否小于15，结果小于，所以a0寄存器被置为1，用数码管显示
addi  $s0,$0,16
sltiu $a0,$s0,15	#$s0=16，不小于15，所以a0置0
syscall			#显示a0 = 0
addi  $s0,$0,14
sltiu $a0,$s0,15	#$s0=14，小于15，所以a0置1
syscall			#显示a0 = 1
#sltiu测试结束

#lbu测试
#将寄存器a0赋值为0x12345678，用数码管显示
#用s指令将a0寄存器的值写入4号内存单元，4-7号内存的值分别为0x78，0x56，0x0，0x0
#用lbu指令从5号内存单元读取1个字节，其值应为0x56，用数码管显示
addi  $a0,$0,0x00005678
syscall			#显示a0=0x5678
sw    $a0,4($0)
lbu   $a0,5($0)
syscall			#显示a0= 0x56
#lbu测试结束

#blez测试
#对a0寄存器赋不同的值，从而执行不同的跳转
#先赋值为8，大于0，所以不跳转，继续执行
#再赋值为0，满足a0<=0, 跳过几条无关的指令，跳到j_next处
#最后赋值-6，也满足a0<=0，跳转到最后的停机指令
#以上三种跳转满足了所有可能的取值情况，a0大于0，等于0，或小于0
addi  $a0,$0,8
syscall			#显示a0=8
blez  $a0,j_end		#a0=8>0,不跳转
addi  $a0,$0,0
syscall			#显示a0=0
blez  $a0,j_next	#a0=0 <=0,跳转
addi $s1,$zero, 1	#三行无关代码，用于跳转的偏移量生成
addi $s2,$zero, 2
addi $s3,$zero, 3
j_next:
addi  $a0,$0,-6
syscall			#显示a0 = -6
blez  $a0,j_end		#a0=-6 <=0, 跳转
addi $s1,$zero, 1	#三行无关代码，用于跳转的偏移量生成
addi $s2,$zero, 2
addi $s3,$zero, 3
j_end:
addi  $v0,$0,10
syscall			#v0=10，结束
